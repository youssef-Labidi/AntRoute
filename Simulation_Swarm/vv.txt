*****SIMULATON 2 

import React, { useState, useEffect, useRef } from 'react';
import { Play, Pause, RotateCcw, Plus, Settings, Activity, Zap, TrendingUp, Users, Radio } from 'lucide-react';

// Configuration
const CONFIG = {
  GRID_SIZE: 50,
  CELL_SIZE: 12,
  AGENT_SPEED: 0.05,
  BEACON_PERIOD: 50,
  COMM_RANGE: 150,
  PHEROMONE_DECAY: 0.98,
  PHEROMONE_WEIGHT: 0.3,
  OFFER_TIMEOUT: 50,
  FAILURE_BEACON_THRESHOLD: 5,
  PACKET_LOSS_RATE: 0.05
};

// Utility functions
const distance = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
const manhattanDist = (p1, p2) => Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);

// Map class
class GridMap {
  constructor(size) {
    this.size = size;
    this.blocked = new Set();
    this.zones = [];
    this.generateMap();
  }

  generateMap() {
    // Create building blocks in zones
    const buildings = [
      {x: 10, y: 10, w: 5, h: 5},
      {x: 30, y: 15, w: 6, h: 4},
      {x: 20, y: 35, w: 4, h: 6},
      {x: 40, y: 25, w: 3, h: 7},
      {x: 5, y: 30, w: 4, h: 4},
    ];

    buildings.forEach(b => {
      for (let x = b.x; x < b.x + b.w; x++) {
        for (let y = b.y; y < b.y + b.h; y++) {
          this.blocked.add(`${x},${y}`);
        }
      }
    });
  }

  isBlocked(x, y) {
    return this.blocked.has(`${x},${y}`);
  }

  getNeighbors(pos) {
    const dirs = [[0,1], [1,0], [0,-1], [-1,0], [1,1], [1,-1], [-1,1], [-1,-1]];
    return dirs
      .map(([dx, dy]) => ({x: pos.x + dx, y: pos.y + dy}))
      .filter(p => p.x >= 0 && p.x < this.size && p.y >= 0 && p.y < this.size && !this.isBlocked(p.x, p.y));
  }
}

// A* pathfinding with pheromone
const aStar = (start, goal, map, pheromoneMap, lambda, horizon = 100) => {
  const openSet = [{pos: start, g: 0, h: manhattanDist(start, goal), f: manhattanDist(start, goal), path: [start]}];
  const closedSet = new Set();
  
  while (openSet.length > 0) {
    openSet.sort((a, b) => a.f - b.f);
    const current = openSet.shift();
    
    if (current.pos.x === goal.x && current.pos.y === goal.y) {
      return current.path;
    }
    
    const key = `${current.pos.x},${current.pos.y}`;
    if (closedSet.has(key)) continue;
    closedSet.add(key);
    
    for (const neighbor of map.getNeighbors(current.pos)) {
      const nKey = `${neighbor.x},${neighbor.y}`;
      if (closedSet.has(nKey)) continue;
      
      const pheromone = pheromoneMap.get(nKey) || 0;
      const pheromoneCost = pheromone > 2 ? pheromone * 0.5 : 0;
      const g = current.g + 1 + pheromoneCost;
      const h = manhattanDist(neighbor, goal);
      const f = g + h;
      
      openSet.push({
        pos: neighbor,
        g, h, f,
        path: [...current.path, neighbor]
      });
    }
    
    if (current.path.length > horizon) break;
  }
  
  return [start];
};

// Agent class
class Agent {
  constructor(id, pos, map) {
    this.id = id;
    this.pos = pos;
    this.capacity = 10;
    this.speed = CONFIG.AGENT_SPEED;
    this.energy = 100;
    this.missionQueue = [];
    this.currentPath = [];
    this.pheromoneMap = new Map();
    this.taskCount = 0;
    this.completedTasks = 0;
    this.assignedRequest = null;
    this.lastBeacon = 0;
    this.map = map;
    this.failed = false;
    this.messagesSent = 0;
    this.totalDistance = 0;
    this.deliveryTimes = [];
    this.taskStartTime = null;
  }

  computeUtility(request, currentTime) {
    const distToPickup = distance(this.pos, request.pickup);
    const distToDropoff = distance(request.pickup, request.dropoff);
    const totalDist = distToPickup + distToDropoff;
    
    const eta = totalDist / this.speed + this.missionQueue.length * 10;
    const energyCost = totalDist * 0.5;
    const fairnessPenalty = this.taskCount * 3;
    const priorityBonus = request.priority * 15;
    
    return eta + energyCost + fairnessPenalty - priorityBonus;
  }

  submitBid(request, currentTime) {
    if (this.failed) return null;
    if (this.energy < 20) return null;
    if (request.weight > this.capacity) return null;
    
    const utility = this.computeUtility(request, currentTime);
    this.messagesSent++;
    return {
      agentId: this.id,
      requestId: request.id,
      utility,
      timestamp: currentTime
    };
  }

  assignTask(request) {
    this.assignedRequest = request;
    this.missionQueue.push(
      { type: 'pickup', pos: request.pickup, requestId: request.id },
      { type: 'dropoff', pos: request.dropoff, requestId: request.id }
    );
    this.taskCount++;
    this.taskStartTime = Date.now();
  }

  planPath() {
    if (this.missionQueue.length === 0) {
      this.currentPath = [];
      return;
    }
    
    const target = this.missionQueue[0].pos;
    this.currentPath = aStar(
      this.pos,
      target,
      this.map,
      this.pheromoneMap,
      CONFIG.PHEROMONE_WEIGHT
    );
  }

  move() {
    if (this.failed) return;
    
    if (this.currentPath.length <= 1) {
      if (this.missionQueue.length > 0) {
        const completed = this.missionQueue.shift();
        if (completed.type === 'dropoff') {
          this.completedTasks++;
          if (this.taskStartTime) {
            this.deliveryTimes.push(Date.now() - this.taskStartTime);
            this.taskStartTime = null;
          }
        }
        if (this.missionQueue.length === 0) {
          this.assignedRequest = null;
        }
        this.planPath();
      }
      return;
    }
    
    const prevPos = this.pos;
    this.pos = this.currentPath[1];
    this.currentPath.shift();
    this.totalDistance += distance(prevPos, this.pos);
    this.energy -= 0.15;
    
    const key = `${this.pos.x},${this.pos.y}`;
    this.pheromoneMap.set(key, (this.pheromoneMap.get(key) || 0) + 1);
    
    if (this.energy <= 0) {
      this.fail();
    }
  }

  beacon(currentTime) {
    if (this.failed) return;
    this.lastBeacon = currentTime;
    this.messagesSent++;
    
    this.pheromoneMap.forEach((value, key) => {
      const newValue = value * CONFIG.PHEROMONE_DECAY;
      if (newValue < 0.1) {
        this.pheromoneMap.delete(key);
      } else {
        this.pheromoneMap.set(key, newValue);
      }
    });
  }

  fail() {
    this.failed = true;
    this.energy = 0;
  }

  getNeighbors(agents) {
    return agents.filter(a => 
      a.id !== this.id && 
      !a.failed && 
      distance(this.pos, a.pos) * CONFIG.CELL_SIZE < CONFIG.COMM_RANGE
    );
  }
}

// Main simulator component
const HiveRouteSimulator = () => {
  const [running, setRunning] = useState(false);
  const [time, setTime] = useState(0);
  const [agents, setAgents] = useState([]);
  const [requests, setRequests] = useState([]);
  const [pendingRequests, setPendingRequests] = useState([]);
  const [completedRequests, setCompletedRequests] = useState([]);
  const [failedAgents, setFailedAgents] = useState([]);
  const [stats, setStats] = useState({ 
    otr: 100, 
    avgEnergy: 0, 
    totalMessages: 0,
    gini: 0,
    avgDeliveryTime: 0,
    totalDeliveries: 0,
    failureRecoveries: 0
  });
  const [scenario, setScenario] = useState('normal');
  const [autoSpawn, setAutoSpawn] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const mapRef = useRef(new GridMap(CONFIG.GRID_SIZE));
  const canvasRef = useRef(null);
  const spawnCounterRef = useRef(0);

  useEffect(() => {
    initSimulation();
  }, []);

  const initSimulation = () => {
    const map = mapRef.current;
    const newAgents = [];
    const positions = [
      {x: 5, y: 5}, {x: 45, y: 5}, {x: 25, y: 25},
      {x: 5, y: 45}, {x: 45, y: 45}, {x: 15, y: 25},
      {x: 35, y: 25}
    ];
    
    const numAgents = scenario === 'small' ? 4 : scenario === 'large' ? 10 : 6;
    
    for (let i = 0; i < numAgents; i++) {
      const pos = positions[i % positions.length];
      newAgents.push(new Agent(i, {...pos}, map));
    }
    setAgents(newAgents);
    setRequests([]);
    setPendingRequests([]);
    setCompletedRequests([]);
    setFailedAgents([]);
    setTime(0);
    spawnCounterRef.current = 0;
  };

  const addRequest = () => {
    const map = mapRef.current;
    const getRandomPos = () => {
      let x, y;
      do {
        x = Math.floor(Math.random() * CONFIG.GRID_SIZE);
        y = Math.floor(Math.random() * CONFIG.GRID_SIZE);
      } while (map.isBlocked(x, y));
      return {x, y};
    };

    const request = {
      id: Date.now() + Math.random(),
      pickup: getRandomPos(),
      dropoff: getRandomPos(),
      weight: Math.floor(Math.random() * 8) + 2,
      priority: Math.random() > 0.7 ? 2 : 1,
      status: 'pending',
      spawnTime: time
    };
    setPendingRequests(prev => [...prev, request]);
  };

  const injectFailure = () => {
    const activeAgents = agents.filter(a => !a.failed);
    if (activeAgents.length > 0) {
      const victim = activeAgents[Math.floor(Math.random() * activeAgents.length)];
      victim.fail();
      setFailedAgents(prev => [...prev, victim.id]);
    }
  };

  const runAuction = (request, isRecovery = false) => {
    const bids = agents
      .map(agent => {
        const bid = agent.submitBid(request, time);
        if (bid && isRecovery) {
          bid.utility *= 0.8;
        }
        return bid;
      })
      .filter(bid => bid !== null);

    if (bids.length === 0) {
      setRequests(prev => prev.filter(r => r.id !== request.id));
      return null;
    }

    bids.sort((a, b) => a.utility - b.utility);
    const winner = agents.find(a => a.id === bids[0].agentId);
    
    if (winner) {
      winner.assignTask(request);
      winner.planPath();
      return winner.id;
    }
    return null;
  };

  const handleTakeover = (failedAgent) => {
    if (failedAgent.assignedRequest) {
      const request = failedAgent.assignedRequest;
      request.status = 'pending';
      const winnerId = runAuction(request, true);
      
      if (winnerId !== null) {
        setStats(prev => ({ ...prev, failureRecoveries: prev.failureRecoveries + 1 }));
        setRequests(prev => prev.map(r => 
          r.id === request.id ? { ...r, status: 'assigned', assignedTo: winnerId, recovered: true } : r
        ));
      }
    }
  };

  const calculateGini = (agents) => {
    const tasks = agents.map(a => a.completedTasks).sort((a, b) => a - b);
    if (tasks.length === 0) return 0;
    
    const n = tasks.length;
    let sum = 0;
    tasks.forEach((val, i) => {
      sum += (2 * (i + 1) - n - 1) * val;
    });
    
    const total = tasks.reduce((a, b) => a + b, 0);
    return total === 0 ? 0 : sum / (n * total);
  };

  useEffect(() => {
    if (!running) return;

    const interval = setInterval(() => {
      setTime(t => t + 1);
      
      // Auto-spawn requests based on scenario
      if (autoSpawn) {
        spawnCounterRef.current++;
        const spawnRate = scenario === 'peak' ? 30 : scenario === 'stress' ? 15 : 60;
        if (spawnCounterRef.current % spawnRate === 0) {
          addRequest();
        }
      }

      // Detect failures
      setAgents(prevAgents => {
        const newlyFailed = prevAgents.filter(a => 
          !a.failed && 
          time - a.lastBeacon > CONFIG.FAILURE_BEACON_THRESHOLD && 
          time > CONFIG.FAILURE_BEACON_THRESHOLD
        );
        
        newlyFailed.forEach(handleTakeover);
        
        return prevAgents;
      });

      // Process pending requests
      setPendingRequests(prev => {
        const toProcess = [];
        const remaining = [];
        
        prev.forEach(req => {
          if (time - req.spawnTime >= CONFIG.OFFER_TIMEOUT / 10) {
            toProcess.push(req);
          } else {
            remaining.push(req);
          }
        });

        toProcess.forEach(req => {
          if (Math.random() > CONFIG.PACKET_LOSS_RATE) {
            const winnerId = runAuction(req);
            if (winnerId !== null) {
              setRequests(r => [...r, { ...req, status: 'assigned', assignedTo: winnerId }]);
            }
          } else {
            remaining.push(req);
          }
        });

        return remaining;
      });

      // Move agents and beacon
      setAgents(prevAgents => {
        return prevAgents.map(agent => {
          agent.move();
          
          if (time % Math.floor(CONFIG.BEACON_PERIOD / 10) === 0) {
            agent.beacon(time);
          }
          
          if (agent.currentPath.length === 0 && agent.missionQueue.length > 0) {
            agent.planPath();
          }
          
          return agent;
        });
      });

      // Check completed requests
      setRequests(prev => {
        const stillActive = [];
        prev.forEach(req => {
          const assignedAgent = agents.find(a => a.id === req.assignedTo);
          if (assignedAgent && !assignedAgent.assignedRequest) {
            setCompletedRequests(c => [...c, { ...req, completionTime: time }]);
          } else {
            stillActive.push(req);
          }
        });
        return stillActive;
      });

      // Update stats
      if (agents.length > 0) {
        const activeAgents = agents.filter(a => !a.failed);
        const avgEnergy = activeAgents.length > 0 
          ? activeAgents.reduce((sum, a) => sum + a.energy, 0) / activeAgents.length 
          : 0;
        const totalMessages = agents.reduce((sum, a) => sum + a.messagesSent, 0);
        const totalDeliveries = agents.reduce((sum, a) => sum + a.completedTasks, 0);
        const allTimes = agents.flatMap(a => a.deliveryTimes);
        const avgTime = allTimes.length > 0 
          ? allTimes.reduce((a, b) => a + b, 0) / allTimes.length / 100 
          : 0;
        const gini = calculateGini(agents);
        const totalRequests = completedRequests.length + requests.length;
        const otr = totalRequests > 0 ? (completedRequests.length / totalRequests) * 100 : 100;

        setStats({
          avgEnergy: avgEnergy.toFixed(1),
          totalMessages,
          totalDeliveries,
          avgDeliveryTime: avgTime.toFixed(1),
          gini: gini.toFixed(3),
          otr: otr.toFixed(1),
          failureRecoveries: stats.failureRecoveries
        });
      }

      draw();
    }, 100);

    return () => clearInterval(interval);
  }, [running, time, agents, pendingRequests, autoSpawn, scenario]);

  const draw = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, w, h);

    // Draw grid
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= CONFIG.GRID_SIZE; i += 5) {
      ctx.beginPath();
      ctx.moveTo(i * CONFIG.CELL_SIZE, 0);
      ctx.lineTo(i * CONFIG.CELL_SIZE, h);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, i * CONFIG.CELL_SIZE);
      ctx.lineTo(w, i * CONFIG.CELL_SIZE);
      ctx.stroke();
    }

    // Draw blocked cells
    const map = mapRef.current;
    ctx.fillStyle = '#1e293b';
    map.blocked.forEach(key => {
      const [x, y] = key.split(',').map(Number);
      ctx.fillRect(x * CONFIG.CELL_SIZE, y * CONFIG.CELL_SIZE, CONFIG.CELL_SIZE, CONFIG.CELL_SIZE);
    });

    // Draw pheromones
    const globalPheromone = new Map();
    agents.forEach(agent => {
      agent.pheromoneMap.forEach((value, key) => {
        globalPheromone.set(key, (globalPheromone.get(key) || 0) + value);
      });
    });

    globalPheromone.forEach((value, key) => {
      const [x, y] = key.split(',').map(Number);
      const alpha = Math.min(value / 10, 0.5);
      ctx.fillStyle = `rgba(168, 85, 247, ${alpha})`;
      ctx.fillRect(x * CONFIG.CELL_SIZE, y * CONFIG.CELL_SIZE, CONFIG.CELL_SIZE, CONFIG.CELL_SIZE);
    });

    // Draw communication ranges
    agents.forEach((agent, i) => {
      if (!agent.failed) {
        ctx.strokeStyle = `rgba(59, 130, 246, 0.1)`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(
          agent.pos.x * CONFIG.CELL_SIZE + 6, 
          agent.pos.y * CONFIG.CELL_SIZE + 6, 
          CONFIG.COMM_RANGE / CONFIG.CELL_SIZE * 12, 
          0, 2 * Math.PI
        );
        ctx.stroke();
      }
    });

    // Draw requests
    requests.forEach(req => {
      if (req.status === 'assigned') {
        // Pickup
        ctx.fillStyle = req.recovered ? '#f59e0b' : '#fbbf24';
        ctx.beginPath();
        ctx.arc(req.pickup.x * CONFIG.CELL_SIZE + 6, req.pickup.y * CONFIG.CELL_SIZE + 6, 5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Dropoff
        ctx.fillStyle = req.recovered ? '#10b981' : '#34d399';
        ctx.beginPath();
        ctx.arc(req.dropoff.x * CONFIG.CELL_SIZE + 6, req.dropoff.y * CONFIG.CELL_SIZE + 6, 5, 0, 2 * Math.PI);
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Connection line
        ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(req.pickup.x * CONFIG.CELL_SIZE + 6, req.pickup.y * CONFIG.CELL_SIZE + 6);
        ctx.lineTo(req.dropoff.x * CONFIG.CELL_SIZE + 6, req.dropoff.y * CONFIG.CELL_SIZE + 6);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    });

    // Draw agents
    const colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316'];
    agents.forEach((agent, i) => {
      if (agent.failed) {
        ctx.fillStyle = '#64748b';
        ctx.globalAlpha = 0.5;
      } else {
        ctx.fillStyle = colors[i % colors.length];
        ctx.globalAlpha = 1;
      }
      
      ctx.beginPath();
      ctx.arc(agent.pos.x * CONFIG.CELL_SIZE + 6, agent.pos.y * CONFIG.CELL_SIZE + 6, 7, 0, 2 * Math.PI);
      ctx.fill();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw path
      if (agent.currentPath.length > 1 && !agent.failed) {
        ctx.strokeStyle = colors[i % colors.length] + '50';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(agent.pos.x * CONFIG.CELL_SIZE + 6, agent.pos.y * CONFIG.CELL_SIZE + 6);
        agent.currentPath.slice(1, 15).forEach(p => {
          ctx.lineTo(p.x * CONFIG.CELL_SIZE + 6, p.y * CONFIG.CELL_SIZE + 6);
        });
        ctx.stroke();
      }

      // Agent ID
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(agent.id.toString(), agent.pos.x * CONFIG.CELL_SIZE + 6, agent.pos.y * CONFIG.CELL_SIZE + 4);
      
      ctx.globalAlpha = 1;
    });
  };

  useEffect(() => {
    draw();
  }, [agents, requests]);

  return (
    <div className="w-full min-h-screen bg-slate-950 text-white p-4">
      <div className="max-w-[1800px] mx-auto flex gap-4 h-[95vh]">
        <div className="flex-1 flex flex-col gap-4 min-w-0">
          <div className="bg-slate-900 rounded-xl p-6 shadow-2xl border border-slate-800">
            <div className="flex items-center justify-between">
              <div>
                <h1 className="text-3xl font-bold mb-2 flex items-center gap-3">
                  <Activity className="w-8 h-8 text-purple-400" />
                  AntRoute Simulator
                  <span className="text-lg text-slate-400 font-normal">v1.0</span>
                </h1>
                <p className="text-slate-400">Decentralized Multi-Agent Delivery System with Failure Recovery</p>
              </div>
              <div className="flex gap-2">
                <button
                  onClick={() => setShowSettings(!showSettings)}
                  className="p-2 bg-slate-800 hover:bg-slate-700 rounded-lg transition"
                >
                  <Settings className="w-5 h-5" />
                </button>
              </div>
            </div>

            {showSettings && (
              <div className="mt-4 p-4 bg-slate-800 rounded-lg border border-slate-700">
                <h3 className="font-semibold mb-3">Scenario Selection</h3>
                <div className="grid grid-cols-4 gap-2">
                  {['normal', 'small', 'large', 'peak', 'stress'].map(s => (
                    <button
                      key={s}
                      onClick={() => { setScenario(s); initSimulation(); }}
                      className={`px-3 py-2 rounded ${scenario === s ? 'bg-purple-600' : 'bg-slate-700 hover:bg-slate-600'} transition capitalize`}
                    >
                      {s}
                    </button>
                  ))}
                </div>
                <div className="mt-3 flex items-center gap-2">
                  <input 
                    type="checkbox" 
                    checked={autoSpawn}
                    onChange={(e) => setAutoSpawn(e.target.checked)}
                    className="w-4 h-4"
                  />
                  <label className="text-sm">Auto-spawn requests</label>
                </div>
              </div>
            )}
          </div>

          <div className="bg-slate-900 rounded-xl p-4 flex-1 flex items-center justify-center border border-slate-800 shadow-2xl">
            <canvas 
              ref={canvasRef} 
              width={CONFIG.GRID_SIZE * CONFIG.CELL_SIZE}
              height={CONFIG.GRID_SIZE * CONFIG.CELL_SIZE}
              className="border-2 border-slate-700 rounded-lg shadow-lg"
              style={{imageRendering: 'crisp-edges'}}
            />
          </div>

          <div className="bg-slate-900 rounded-xl p-4 flex gap-3 border border-slate-800 shadow-xl">
            <button
              onClick={() => setRunning(!running)}
              className="flex items-center gap-2 px-6 py-3 bg-gradient-to-r from-purple-600 to-purple-700 hover:from-purple-700 hover:to-purple-800 rounded-lg transition font-semibold shadow-lg"
            >
              {running ? <Pause className="w-5 h-5" /> : <Play className="w-5 h-5" />}
              {running ? 'Pause' : 'Start'}
            </button>
            <button
              onClick={initSimulation}
              className="flex items-center gap-2 px-6 py-3 bg-slate-700 hover:bg-slate-600 rounded-lg transition font-semibold"
            >
              <RotateCcw className="w-5 h-5" />
              Reset
            </button>
            <button
              onClick={addRequest}
              className="flex items-center gap-2 px-6 py-3 bg-emerald-600 hover:bg-emerald-700 rounded-lg transition font-semibold"
            >
              <Plus className="w-5 h-5" />
              Add Request
            </button>
            <button
              onClick={injectFailure}
              className="flex items-center gap-2 px-6 py-3 bg-red-600 hover:bg-red-700 rounded-lg transition font-semibold"
            >
              <Zap className="w-5 h-5" />
              Inject Failure
            </button>
            <div className="flex-1"></div>
            <div className="flex items-center gap-2 px-4 py-2 bg-slate-800 rounded-lg font-mono text-lg">
              <Activity className="w-5 h-5 text-purple-400" />
              Time: {time}
            </div>
          </div>
        </div>

        <div className="w-96 flex flex-col gap-4 overflow-y-auto">
          <div className="bg-slate-900 rounded-xl p-5 border border-slate-800 shadow-xl">
            <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
              <TrendingUp className="w-5 h-5 text-emerald-400" />
              Key Performance Indicators
            </h2>
            <div className="space-y-3">
              <div className="bg-slate-800 rounded-lg p-3">
                <div className="flex justify-between items-center mb-1">
                  <span className="text-sm text-slate-400">On-Time Rate (OTR)</span>
                  <span className="text-2xl font-bold text-emerald-400">{stats.otr}%</span>
                </div>
                <div className="w-full bg-slate-700 rounded-full h-2">
                  <div className="bg-emerald-500 h-2 rounded-full transition-all" style={{width: `${stats.otr}%`}}></div>
                </div>
              </div>
              
              <div className="bg-slate-800 rounded-lg p-3">
                <div className="flex justify-between items-center">
                  <span className="text-sm text-slate-400">Gini Coefficient</span>
                  <span className="text-xl font-bold text-blue-400">{stats.gini}</span>
                </div>
                <p className="text-xs text-slate-500 mt-1">Workload fairness (0 = perfect)</p>
              </div>

              <div className="grid grid-cols-2 gap-3">
                <div className="bg-slate-800 rounded-lg p-3">
                  <div className="text-xs text-slate-400 mb-1">Avg Energy</div>
                  <div className="text-xl font-bold text-yellow-400">{stats.avgEnergy}%</div>
                </div>
                <div className="bg-slate-800 rounded-lg p-3">
                  <div className="text-xs text-slate-400 mb-1">Total Messages</div>
                  <div className="text-xl font-bold text-purple-400">{stats.totalMessages}</div>
                </div>
              </div>

              <div className="grid grid-cols-2 gap-3">
                <div className="bg-slate-800 rounded-lg p-3">
                  <div className="text-xs text-slate-400 mb-1">Deliveries</div>
                  <div className="text-xl font-bold text-emerald-400">{stats.totalDeliveries}</div>
                </div>
                <div className="bg-slate-800 rounded-lg p-3">
                  <div className="text-xs text-slate-400 mb-1">Avg Time</div>
                  <div className="text-xl font-bold text-cyan-400">{stats.avgDeliveryTime}s</div>
                </div>
              </div>

              <div className="bg-slate-800 rounded-lg p-3">
                <div className="flex justify-between items-center">
                  <span className="text-sm text-slate-400">Failure Recoveries</span>
                  <span className="text-xl font-bold text-orange-400">{stats.failureRecoveries}</span>
                </div>
              </div>

              <div className="bg-slate-800 rounded-lg p-3">
                <div className="text-xs text-slate-400 mb-2">System Status</div>
                <div className="space-y-1 text-xs">
                  <div className="flex justify-between">
                    <span className="text-slate-500">Active Tasks:</span>
                    <span className="font-mono text-white">{requests.length}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-slate-500">Pending:</span>
                    <span className="font-mono text-yellow-400">{pendingRequests.length}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-slate-500">Completed:</span>
                    <span className="font-mono text-emerald-400">{completedRequests.length}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-slate-500">Failed Agents:</span>
                    <span className="font-mono text-red-400">{failedAgents.length}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div className="bg-slate-900 rounded-xl p-5 flex-1 overflow-auto border border-slate-800 shadow-xl">
            <h2 className="text-xl font-bold mb-4 flex items-center gap-2 sticky top-0 bg-slate-900 pb-2">
              <Users className="w-5 h-5 text-blue-400" />
              Agent Fleet Status
            </h2>
            <div className="space-y-3">
              {agents.map((agent, i) => {
                const colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316'];
                const color = colors[i % colors.length];
                return (
                  <div key={agent.id} className={`rounded-lg p-4 border-l-4 ${agent.failed ? 'bg-slate-800 border-slate-600' : 'bg-slate-800'}`} style={{borderLeftColor: agent.failed ? '#64748b' : color}}>
                    <div className="flex justify-between items-start mb-2">
                      <div className="flex items-center gap-2">
                        <div className="w-3 h-3 rounded-full" style={{backgroundColor: agent.failed ? '#64748b' : color}}></div>
                        <span className="font-bold">Agent {agent.id}</span>
                        {agent.failed && <span className="text-xs bg-red-600 px-2 py-0.5 rounded">FAILED</span>}
                      </div>
                      <span className="text-xs text-slate-400">
                        {agent.energy.toFixed(0)}% âš¡
                      </span>
                    </div>
                    
                    <div className="grid grid-cols-2 gap-2 text-xs mb-2">
                      <div>
                        <span className="text-slate-500">Position:</span>
                        <span className="ml-1 font-mono">({agent.pos.x}, {agent.pos.y})</span>
                      </div>
                      <div>
                        <span className="text-slate-500">Distance:</span>
                        <span className="ml-1 font-mono">{agent.totalDistance.toFixed(0)}m</span>
                      </div>
                    </div>

                    <div className="grid grid-cols-3 gap-2 text-xs mb-2">
                      <div className="bg-slate-700 rounded p-2 text-center">
                        <div className="text-slate-400">Tasks</div>
                        <div className="font-bold text-lg">{agent.taskCount}</div>
                      </div>
                      <div className="bg-slate-700 rounded p-2 text-center">
                        <div className="text-slate-400">Done</div>
                        <div className="font-bold text-lg text-emerald-400">{agent.completedTasks}</div>
                      </div>
                      <div className="bg-slate-700 rounded p-2 text-center">
                        <div className="text-slate-400">Queue</div>
                        <div className="font-bold text-lg text-yellow-400">{agent.missionQueue.length}</div>
                      </div>
                    </div>

                    <div className="text-xs space-y-1">
                      <div className="flex items-center gap-2 text-slate-400">
                        <Radio className="w-3 h-3" />
                        <span>Messages sent: {agent.messagesSent}</span>
                      </div>
                      {agent.assignedRequest && !agent.failed && (
                        <div className="flex items-center gap-2 text-emerald-400 mt-2 bg-emerald-950 p-2 rounded">
                          <Activity className="w-3 h-3" />
                          <span className="font-semibold">Active: Request #{agent.assignedRequest.id.toFixed(0)}</span>
                        </div>
                      )}
                    </div>

                    {!agent.failed && (
                      <div className="mt-2 w-full bg-slate-700 rounded-full h-1.5">
                        <div 
                          className="bg-gradient-to-r from-emerald-500 to-emerald-600 h-1.5 rounded-full transition-all"
                          style={{width: `${agent.energy}%`}}
                        ></div>
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </div>

          <div className="bg-slate-900 rounded-xl p-5 border border-slate-800 shadow-xl">
            <h2 className="text-lg font-bold mb-3">Legend & Info</h2>
            <div className="space-y-2 text-xs">
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 rounded-full bg-red-500 border-2 border-white"></div>
                <span>Agents (colored by ID)</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 rounded-full bg-yellow-400 border border-white"></div>
                <span>Pickup location</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 rounded-full bg-emerald-400 border border-white"></div>
                <span>Dropoff location</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 bg-purple-500 opacity-40 rounded"></div>
                <span>Pheromone density</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 rounded-full bg-slate-600"></div>
                <span>Failed agent</span>
              </div>
              <div className="flex items-center gap-2">
                <div className="w-4 h-4 rounded-full bg-orange-500 border border-white"></div>
                <span>Recovered task</span>
              </div>
            </div>

            <div className="mt-4 pt-4 border-t border-slate-700 text-xs text-slate-400 space-y-1">
              <p><strong>Comm Range:</strong> {CONFIG.COMM_RANGE}px</p>
              <p><strong>Pheromone Weight:</strong> {CONFIG.PHEROMONE_WEIGHT}</p>
              <p><strong>Beacon Period:</strong> {CONFIG.BEACON_PERIOD}ms</p>
              <p><strong>Packet Loss:</strong> {(CONFIG.PACKET_LOSS_RATE * 100).toFixed(1)}%</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default HiveRouteSimulator;